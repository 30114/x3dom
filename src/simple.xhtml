<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<title>Simple WebGL example</title>
		<style>
		body { font-family: sans-serif; }
		X3D { display: none; }
		/*canvas { border: solid; float: left; margin-right: 1em; margin-bottom: 1em; }*/
		p.case { clear: both; border-top: 1px solid #888; }
		p.log { height: 10em; overflow: auto; white-space: -moz-pre-wrap; white-space: pre-wrap; font-size: x-small; }
		</style>
	</head>

<!--<script type="text/javascript" >


// Test the x3dom object

    
var userData = {
    shaderProgram: null
};        
    
function loadShader(gl, shaderType, shaderSource)
{
    // Create the shader object
    var shader = gl.createShader(shaderType);
    if (shader == 0) return 0;

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status. OpenGL ES2.0 defines a "getShaderiv", WebGL only has "getShaderi"
    // which returns the result rather than putting it into the 3rd parameter.
    var compiled = gl.getShaderi(shader, gl.COMPILE_STATUS);
    if (!compiled) {
        // Something went wrong during compilation; get the error
        var error = gl.getShaderInfoLog(shader);
        alert("Error compiling shader source: " + error);
        // log(error);
        gl.deleteShader(shader);
        return 0;
    }

    return shader;
}



function init() {
    // Aquire the canvas element
    var canvas = document.getElementById("canvas");
    var gl = getContext(canvas);
    userData.gl = gl;
        
    // Setup a vertex and fragment shader and attach it to program
    
    // put shader source in variables; see later examples
    // for a more efficient way to do this within HTML.
    var vertexShaderSource = 
        "attribute vec4 vPosition;     \n" +
        "void main()                   \n" +
        "{                             \n" +
        "  gl_Position = vPosition;    \n" +
        "} ";
    var fragmentShaderSource =
        "/*precision mediump float;*/  \n" +
        "void main()                   \n" +
        "{                             \n" +
        "  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n" +
        "} ";

    // create our shaders
    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);     
    
    // Create the shader program object
    var programObject = gl.createProgram();
    if (programObject == 0) return false;
    
    // Store the shader program in the global user data (which is not 
    // the best solution)
    userData.shaderProgram = programObject;

    // Attach our two shaders to the program
    gl.attachShader (programObject, vertexShader);
    gl.attachShader (programObject, fragmentShader);
    
    // Link the program
    gl.linkProgram(programObject);

    // Check the link status
    var linked = gl.getProgrami(programObject, gl.LINK_STATUS);
    if (!linked) {
        // something went wrong with the link
        var error = gl.getProgramInfoLog (programObject);
        log(error);
    
        gl.deleteProgram(programObject);
        gl.deleteShader(fragmentShader);
        gl.deleteShader(vertexShader);
    
        return false;
    }
    
    return true;
}


function draw(gl)
{
    var vertices = [  0.0,  0.5,  0.0,
                     -0.5, -0.5,  0.0,
                      0.5, -0.5,  0.0  ];

    // Set up the viewport
    //gl.viewport(0, 0, canvasWidth, canvasHeight);
    gl.viewport(0, 0, 200, 150);

    // Clear the color buffer
    
    gl.clearDepthf(1.0);
    gl.clearColor(0.4, 0.4, 0.4, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Use the program object we created in init()
    gl.useProgram(userData.shaderProgram);
    gl.enableVertexAttribArray(0);
    
    // Create a buffer for the vertices
    var verticeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new CanvasFloatArray(vertices), gl.STATIC_DRAW);
    
    // Load the vertex data
    // XXX we seem to have lost the |normalized| and |stride| params!
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);    

    // Do the draw, as triangles
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    
    gl.flush();
}



</script>-->
       

<body>
    
    <canvas id="canvas" width="200" height="150" style="border: 2px solid black"></canvas>

	<p class="case">Boxes
		<X3D xmlns="http://www.web3d.org/specifications/x3d-namespace" width="320" height="240">
		<Scene>
			<Shape>
				<Appearance/>
				<Box/>
			</Shape>
			<Transform translation="4 0 0">
				<Shape>
					<Appearance/>
					<Box size="0.5 1 2"/>
				</Shape>
			</Transform>
			<Viewpoint centerOfRotation="0 0 0" position="0 0 15" orientation="0 1 0 0" fieldOfView="0.661"/>
		</Scene>
		</X3D>
	</p>

    <canvas id="sphereCanvas" width="200" height="150" style="border: 2px solid black"></canvas>
    <p class="case">Spheres
        <X3D xmlns="http://www.web3d.org/specifications/x3d-namespace" width="320" height="240">
        <Scene>
            <Shape>
                <Appearance/>
                <Sphere />
            </Shape>
            <Transform translation="4 0 0">
                <Shape>
                    <Appearance/>
                    <Sphere />
                </Shape>
            </Transform>
            <Viewpoint centerOfRotation="0 0 0" position="0 0 15" orientation="0 1 0 0" fieldOfView="0.661"/>
        </Scene>
        </X3D>
    </p>
    
	<script type="text/javascript" src="x3dom.js"></script>
	<script type="text/javascript" src="gfx_mozwebgl.js"></script>
	<script type="text/javascript" src="x3d.js"></script>
	<script type="text/javascript" src="math.js"></script>
    <script type="text/javascript" src="debug.js"></script>

	<script type="text/javascript" ><![CDATA[

	window.onload = function() {
        var x3ds = document.getElementsByTagNameNS('http://www.web3d.org/specifications/x3d-namespace', 'X3D');
        alert("Found " + x3ds.length + ", " + typeof(x3ds));
        
		var boxCanvas = document.getElementById("canvas"); 
		var boxX3DOM = x3dom(boxCanvas);		
		x3ds = Array.map(x3ds, function (n) { return n });		
		boxX3DOM.load(x3ds[0]);
        
        // Try to initialize a second canvas
        var sphereCanvas = document.getElementById("sphereCanvas"); 
        var sphereX3DOM = x3dom(sphereCanvas);
        sphereX3DOM.load(x3ds[1]);
	};
	]]></script>

</body>
</html>
